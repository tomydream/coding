1. initiallist
vector<int> vec{1,2,3}

2. auto

3.range for

4.nullptr

5. 
enum class ship {
    A,
    B
};

6.
class base {
public:
	virtual void fun1(int);
	virtual void fun2() const;
	void fun3(int);
};

class son :public base {
	//c++ 03 存在隐患
	/*
	void fun1(float);  //不小心写错了参数,ok 编译通过，create a new func
	void fun2();       //不小心少写了const,ok 编译通过，create a new func
	void fun3();
	*/

	// but in c++ 11 更安全清晰
	void fun1(float) override; //编译Error: no func to override
	void fun2() override;      //编译Error: no func to override
	void fun3() override;      //编译Error: no func to override			
};


7.final
// 禁止类被继承 禁止虚函数被重写

8. // default  强制生成默认构造函数

class CPoint2D {
public:
	CPoint2D(double x_,double y_) {
		x = x_;
		y = y_;
	}
	double x;
	double y;
};

int main(){	
	CPoint2D pt;//编译报错，不存在默认构造函数，因为编译器不再生成	
}

class CPoint2D {
public:
	CPoint2D(double x_,double y_) {
		x = x_;
		y = y_;
	}
	CPoint2D() = default;//告诉编译器强制生成
	double x;
	double y;
};

int main(){	
	CPoint2D pt;//ok	
}

9.// delete 放在函数后面 表示函数不能被调用
class dog {
public:
	dog(int age_) {
		age = age_;
	}
	dog(double) = delete;
	int age;
};

int main(){	
	dog(2);   //ok
	dog(4.5); //not ok,已经删除的函数      如果不加delete这个会转换成int
}


10. // lambda
int main(){

	std::vector<CPoint2D> Pts{ {1,1},{3,3},{2,2} };
	std::sort(begin(Pts), end(Pts), [](const CPoint2D& pt1, const CPoint2D& pt2) {
		return  pt1.x < pt2.x;
		});
}

[a,&b] 其中 a 以复制捕获而 b 以引用捕获。
[this] 以引用捕获当前对象（ *this ）
[&] 以引用捕获所有用于 lambda 体内的自动变量，并以引用捕获当前对象，若存在
[=] 以复制捕获所有用于 lambda 体内的自动变量，并以引用捕获当前对象，若存在
[] 不捕获，大部分情况下不捕获就可以了


11. // 智能指针
智能指针其实是个模板类,在构造时初始化,在拷贝构造时增加引用计数,在析构时减少引用计数,需要避免自拷贝
通过get获取管理对象
unique_ptr 当其离开作用域时自动析构。资源所有权的转移只能通过std::move()而不能通过赋值
std::unique_ptr<int> p = std::make_unique<int>(3);
void func2(int* p) {
	*p = 10;
}

int main() {
	std::unique_ptr<int> pInt = std::make_unique<int>(3);
	func2(pInt.get());
}

share_ptr
std::shared_ptr<int> pInt = std::make_shared<int>(3);
// 要避免循环引用的情况,将其中一个改成 weak_ptr
// weak_ptr只引用不计数
struct A;
struct B;
struct B {
	std::shared_ptr<int> pA;
};
struct A {
	std::shared_ptr<int> pB;
};
weak_ptr< T > w	可以指向类型为T的对象的空week_ptr
weak_ptr< T > w(sp)	与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型
w = p	p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象
w.reset()	将w置空
w.use_count()	与w共享对象的shared_ptr的数量
w.expired()	如果w.use_count()为0则返回true，否则返回false
w.lock()	如果w.expired()为true，返回一个空shared_ptr，否则返回其绑定的shared_ptr


12. std::function
// 通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个新的可调用的std::function对象

13. 引用问题
规则1（引用折叠规则）：如果间接的创建一个引用的引用，则这些引用就会“折叠”。在所有情况下（除了一个例外），引用折叠成一个普通的左值引用类型。一种特殊情况下，引用会折叠成右值引用，即右值引用的右值引用， T&& &&。即
左值引用与任意类型叠加都是左值引用


X& &、X& &&、X&& &都折叠成X&
X&& &&折叠为X&&
规则2（右值引用的特殊类型推断规则）：当将一个左值传递给一个参数是右值引用的函数，且此右值引用指向模板类型参数(T&&)时，编译器推断模板参数类型为实参的左值引用

forward的转换规则为:
模板参数为引用类型T、T&&时，返回右值引用
模板参数为引用类型T&时，返回左值引用。
